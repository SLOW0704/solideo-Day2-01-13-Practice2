<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ëŒ€ì¤‘êµí†µ ê²½ë¡œ ì‹œê°í™” ì‹œìŠ¤í…œ</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 0;
            min-height: calc(100vh - 200px);
        }

        .sidebar {
            background: #f8f9fa;
            padding: 30px;
            border-right: 1px solid #e0e0e0;
            overflow-y: auto;
            max-height: calc(100vh - 200px);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
            font-size: 0.95em;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: all 0.3s;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #06b6d4;
            box-shadow: 0 0 0 3px rgba(6, 182, 212, 0.1);
        }

        .btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(6, 182, 212, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .preferences {
            margin-top: 30px;
            padding-top: 30px;
            border-top: 2px solid #e0e0e0;
        }

        .preferences h3 {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #333;
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 8px 12px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .checkbox-label:hover {
            border-color: #06b6d4;
            background: #ecfeff;
        }

        .checkbox-label input {
            width: auto;
        }

        .map-container {
            position: relative;
        }

        #map {
            width: 100%;
            height: calc(100vh - 200px);
        }

        .route-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-width: 350px;
            z-index: 1000;
            max-height: calc(100vh - 280px);
            overflow-y: auto;
        }

        .route-info h3 {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #06b6d4;
            padding-bottom: 10px;
        }

        .route-segment {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            padding: 15px;
            margin-bottom: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #06b6d4;
        }

        .route-icon {
            font-size: 1.5em;
            min-width: 30px;
        }

        .route-details {
            flex: 1;
        }

        .route-details h4 {
            font-size: 1em;
            margin-bottom: 5px;
            color: #333;
        }

        .route-details p {
            font-size: 0.9em;
            color: #666;
            margin: 3px 0;
        }

        .recommendations {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            max-width: 350px;
            z-index: 1000;
        }

        .recommendations h3 {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #333;
        }

        .recommendation-item {
            padding: 10px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .recommendation-item:hover {
            background: #e9ecef;
            transform: translateX(5px);
        }

        .recommendation-item h4 {
            font-size: 0.95em;
            color: #333;
            margin-bottom: 3px;
        }

        .recommendation-item p {
            font-size: 0.85em;
            color: #666;
        }

        .transport-icon {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
            margin-right: 5px;
        }

        .transport-bus {
            background: #10b981;
            color: white;
        }

        .transport-train {
            background: #3b82f6;
            color: white;
        }

        .transport-plane {
            background: #f59e0b;
            color: white;
        }

        .transport-walk {
            background: #6b7280;
            color: white;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #06b6d4;
            font-weight: 600;
        }

        .loading.active {
            display: block;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .sidebar {
                max-height: none;
            }

            #map {
                height: 600px;
            }

            .route-info,
            .recommendations {
                position: relative;
                top: auto;
                left: auto;
                right: auto;
                bottom: auto;
                max-width: 100%;
                margin: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸšŒ ëŒ€ì¤‘êµí†µ ê²½ë¡œ ì‹œê°í™”</h1>
            <p>ì¶œë°œì§€ì™€ ë„ì°©ì§€ë¥¼ ì…ë ¥í•˜ê³  ìµœì ì˜ ê²½ë¡œë¥¼ ì°¾ì•„ë³´ì„¸ìš”</p>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <form id="routeForm">
                    <div class="form-group">
                        <label for="departure">ì¶œë°œ ê±´ë¬¼/ìœ„ì¹˜</label>
                        <input type="text" id="departure" placeholder="ì˜ˆ: ì„œìš¸ì—­" required>
                    </div>

                    <div class="form-group">
                        <label for="arrival">ë„ì°© ê±´ë¬¼/ìœ„ì¹˜</label>
                        <input type="text" id="arrival" placeholder="ì˜ˆ: ë¶€ì‚°ì—­" required>
                    </div>

                    <div class="form-group">
                        <label for="departureTime">ì¶œë°œ ì‹œê°„</label>
                        <input type="datetime-local" id="departureTime" required>
                    </div>

                    <div class="form-group">
                        <label for="travelDuration">ì—¬í–‰ ê¸°ê°„ (ì¼)</label>
                        <input type="number" id="travelDuration" min="1" max="30" value="1" placeholder="1">
                    </div>

                    <div class="form-group">
                        <label for="transportMode">ì„ í˜¸ êµí†µìˆ˜ë‹¨</label>
                        <select id="transportMode">
                            <option value="all">ëª¨ë“  ìˆ˜ë‹¨</option>
                            <option value="bus">ë²„ìŠ¤ ìš°ì„ </option>
                            <option value="train">ê¸°ì°¨ ìš°ì„ </option>
                            <option value="plane">ë¹„í–‰ê¸° í¬í•¨</option>
                            <option value="eco">ì¹œí™˜ê²½ (ë²„ìŠ¤/ê¸°ì°¨)</option>
                        </select>
                    </div>

                    <button type="submit" class="btn">ğŸ” ê²½ë¡œ ê²€ìƒ‰</button>

                    <small style="display: block; margin-top: 10px; color: #666; font-size: 0.85em; text-align: center;">
                        ğŸ’¡ OpenStreetMap ê¸°ë°˜ ì‹¤ì‹œê°„ ê²½ë¡œ ì¡°íšŒ (API í‚¤ ë¶ˆí•„ìš”)
                    </small>

                    <div class="preferences">
                        <h3>ì—¬í–‰ ì·¨í–¥ ì„¤ì •</h3>

                        <label style="font-weight: 600; font-size: 0.9em; color: #666; margin-bottom: 10px; display: block;">ê´€ì‹¬ ì—¬í–‰ì§€</label>
                        <div class="checkbox-group">
                            <label class="checkbox-label">
                                <input type="checkbox" name="interest" value="historical">
                                ì—­ì‚¬/ë¬¸í™”
                            </label>
                            <label class="checkbox-label">
                                <input type="checkbox" name="interest" value="nature">
                                ìì—°/íë§
                            </label>
                            <label class="checkbox-label">
                                <input type="checkbox" name="interest" value="shopping">
                                ì‡¼í•‘
                            </label>
                            <label class="checkbox-label">
                                <input type="checkbox" name="interest" value="cafe">
                                ì¹´í˜
                            </label>
                        </div>

                        <label style="font-weight: 600; font-size: 0.9em; color: #666; margin: 15px 0 10px 0; display: block;">ìŒì‹ ì·¨í–¥</label>
                        <div class="checkbox-group">
                            <label class="checkbox-label">
                                <input type="checkbox" name="food" value="korean">
                                í•œì‹
                            </label>
                            <label class="checkbox-label">
                                <input type="checkbox" name="food" value="western">
                                ì–‘ì‹
                            </label>
                            <label class="checkbox-label">
                                <input type="checkbox" name="food" value="japanese">
                                ì¼ì‹
                            </label>
                            <label class="checkbox-label">
                                <input type="checkbox" name="food" value="chinese">
                                ì¤‘ì‹
                            </label>
                            <label class="checkbox-label">
                                <input type="checkbox" name="food" value="local">
                                í–¥í† ìŒì‹
                            </label>
                        </div>
                    </div>
                </form>

                <div class="loading" id="loading">
                    ê²½ë¡œë¥¼ ê²€ìƒ‰í•˜ëŠ” ì¤‘...
                </div>
            </div>

            <div class="map-container">
                <div id="map"></div>

                <div class="route-info" id="routeInfo" style="display: none;">
                    <h3>ğŸš ê²½ë¡œ ì •ë³´</h3>
                    <div id="routeDetails"></div>
                </div>

                <div class="recommendations" id="recommendations" style="display: none;">
                    <h3>ğŸ“ ì¶”ì²œ ì¥ì†Œ</h3>
                    <div id="recommendationsList"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        // ì§€ë„ ì´ˆê¸°í™”
        const map = L.map('map').setView([37.5665, 126.9780], 7);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);

        // ë§ˆì»¤ ê·¸ë£¹
        let markersLayer = L.layerGroup().addTo(map);
        let routeLayer = L.layerGroup().addTo(map);

        // ì£¼ìš” ë„ì‹œ ì¢Œí‘œ ë°ì´í„°
        const locations = {
            'ì„œìš¸ì—­': { lat: 37.5547, lng: 126.9707 },
            'ê°•ë‚¨ì—­': { lat: 37.4979, lng: 127.0276 },
            'ë¶€ì‚°ì—­': { lat: 35.1151, lng: 129.0419 },
            'ëŒ€êµ¬': { lat: 35.8714, lng: 128.6014 },
            'ëŒ€ì „': { lat: 36.3504, lng: 127.3845 },
            'ê´‘ì£¼': { lat: 35.1595, lng: 126.8526 },
            'ì¸ì²œ': { lat: 37.4563, lng: 126.7052 },
            'ì œì£¼': { lat: 33.4996, lng: 126.5312 },
            'ê²½ì£¼': { lat: 35.8562, lng: 129.2247 },
            'ì „ì£¼': { lat: 35.8242, lng: 127.1480 }
        };

        // êµí†µ ìˆ˜ë‹¨ ì•„ì´ì½˜
        const transportIcons = {
            bus: 'ğŸšŒ',
            train: 'ğŸš„',
            plane: 'âœˆï¸',
            walk: 'ğŸš¶'
        };

        // ì¶”ì²œ ì¥ì†Œ ë°ì´í„°
        const recommendations = {
            'ì„œìš¸ì—­': [
                { type: 'historical', name: 'ê²½ë³µê¶', desc: 'ì¡°ì„ ì‹œëŒ€ ê¶ê¶', category: 'ì—­ì‚¬/ë¬¸í™”' },
                { type: 'shopping', name: 'ëª…ë™', desc: 'ì‡¼í•‘ ê±°ë¦¬', category: 'ì‡¼í•‘' },
                { type: 'cafe', name: 'ë¶ì´Œí•œì˜¥ë§ˆì„', desc: 'ì „í†µ ì¹´í˜', category: 'ì¹´í˜' },
                { type: 'korean', name: 'ê´‘ì¥ì‹œì¥', desc: 'ì „í†µ í•œì‹ ì‹œì¥', category: 'í•œì‹' }
            ],
            'ê°•ë‚¨ì—­': [
                { type: 'shopping', name: 'ì½”ì—‘ìŠ¤ëª°', desc: 'ëŒ€í˜• ì‡¼í•‘ëª°', category: 'ì‡¼í•‘' },
                { type: 'cafe', name: 'ê°€ë¡œìˆ˜ê¸¸', desc: 'íŠ¸ë Œë””í•œ ì¹´í˜ê±°ë¦¬', category: 'ì¹´í˜' },
                { type: 'western', name: 'ì²­ë‹´ë™', desc: 'ê³ ê¸‰ ì–‘ì‹ë‹¹', category: 'ì–‘ì‹' }
            ],
            'ë¶€ì‚°ì—­': [
                { type: 'nature', name: 'í•´ìš´ëŒ€', desc: 'ì•„ë¦„ë‹¤ìš´ í•´ë³€', category: 'ìì—°/íë§' },
                { type: 'historical', name: 'ê°ì²œë¬¸í™”ë§ˆì„', desc: 'ì˜ˆìˆ  ë§ˆì„', category: 'ì—­ì‚¬/ë¬¸í™”' },
                { type: 'local', name: 'ìê°ˆì¹˜ì‹œì¥', desc: 'ì‹ ì„ í•œ í•´ì‚°ë¬¼', category: 'í–¥í† ìŒì‹' },
                { type: 'cafe', name: 'ì†¡ë„í•´ìˆ˜ìš•ì¥', desc: 'ë°”ë‹¤ë·° ì¹´í˜', category: 'ì¹´í˜' }
            ],
            'ì œì£¼': [
                { type: 'nature', name: 'í•œë¼ì‚°', desc: 'ì œì£¼ì˜ ìƒì§• ì‚°', category: 'ìì—°/íë§' },
                { type: 'nature', name: 'ì„±ì‚°ì¼ì¶œë´‰', desc: 'ì¼ì¶œ ëª…ì†Œ', category: 'ìì—°/íë§' },
                { type: 'local', name: 'í‘ë¼ì§€ ê±°ë¦¬', desc: 'ì œì£¼ í‘ë¼ì§€', category: 'í–¥í† ìŒì‹' },
                { type: 'cafe', name: 'ì• ì›” ì¹´í˜ê±°ë¦¬', desc: 'ë°”ë‹¤ë·° ì¹´í˜', category: 'ì¹´í˜' }
            ]
        };

        // í¼ ì œì¶œ ì²˜ë¦¬
        document.getElementById('routeForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            const departure = document.getElementById('departure').value;
            const arrival = document.getElementById('arrival').value;
            const departureTime = document.getElementById('departureTime').value;
            const travelDuration = document.getElementById('travelDuration').value;
            const transportMode = document.getElementById('transportMode').value;

            // ì‚¬ìš©ì ì·¨í–¥ ìˆ˜ì§‘
            const interests = Array.from(document.querySelectorAll('input[name="interest"]:checked'))
                .map(cb => cb.value);
            const foodPrefs = Array.from(document.querySelectorAll('input[name="food"]:checked'))
                .map(cb => cb.value);

            // ë¡œë”© í‘œì‹œ
            document.getElementById('loading').classList.add('active');

            try {
                // OSRM APIë¡œ ì‹¤ì œ ê²½ë¡œ ì¡°íšŒ (ë¬´ë£Œ, API í‚¤ ë¶ˆí•„ìš”)
                await generateRouteWithOSRM(departure, arrival, transportMode, departureTime, travelDuration);

                // ì¶”ì²œ ì¥ì†Œ í‘œì‹œ
                showRecommendations(arrival, interests, foodPrefs);
            } catch (error) {
                alert('ê²½ë¡œ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
                console.error(error);
            } finally {
                // ë¡œë”© ìˆ¨ê¹€
                document.getElementById('loading').classList.remove('active');
            }
        });

        // ë‘ ì§€ì  ê°„ ì‹¤ì œ ê±°ë¦¬ ê³„ì‚° (Haversine formula)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // ì§€êµ¬ ë°˜ì§€ë¦„ (km)
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        function findLocation(query) {
            // ì •í™•í•œ ë§¤ì¹­ ì°¾ê¸°
            for (const [name, coords] of Object.entries(locations)) {
                if (name.includes(query) || query.includes(name.replace('ì—­', ''))) {
                    return { name, ...coords };
                }
            }

            // ê¸°ë³¸ê°’ (ì„œìš¸)
            return { name: query, lat: 37.5665, lng: 126.9780 };
        }

        // OSRM APIë¥¼ ì‚¬ìš©í•œ ì‹¤ì œ ê²½ë¡œ ì¡°íšŒ (ë¬´ë£Œ, API í‚¤ ë¶ˆí•„ìš”)
        async function generateRouteWithOSRM(departure, arrival, mode, time, duration) {
            const startLoc = findLocation(departure);
            const endLoc = findLocation(arrival);

            try {
                // Nominatim APIë¡œ ì£¼ì†Œë¥¼ ì¢Œí‘œë¡œ ë³€í™˜ (OpenStreetMap ê¸°ë°˜)
                const startCoord = await geocodeAddress(departure) || startLoc;
                const endCoord = await geocodeAddress(arrival) || endLoc;

                // ì‹¤ì œ ê±°ë¦¬ ê³„ì‚°
                const actualDistance = calculateDistance(startCoord.lat, startCoord.lng, endCoord.lat, endCoord.lng);

                // OSRM APIë¡œ ì‹¤ì œ ê²½ë¡œ ì¡°íšŒ
                const osrmUrl = `https://router.project-osrm.org/route/v1/driving/${startCoord.lng},${startCoord.lat};${endCoord.lng},${endCoord.lat}?overview=full&geometries=geojson`;

                const response = await fetch(osrmUrl);

                if (!response.ok) {
                    throw new Error('ê²½ë¡œ ì¡°íšŒ ì‹¤íŒ¨');
                }

                const data = await response.json();

                if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
                    // OSRM ì‘ë‹µì„ ê¸°ë°˜ìœ¼ë¡œ ê²½ë¡œ ì‹œê°í™”
                    displayOSRMRoute(data, startCoord, endCoord, departure, arrival, time, duration, actualDistance, mode);
                } else {
                    // OSRM ì‹¤íŒ¨ ì‹œ ìŠ¤ë§ˆíŠ¸ ì¶”ì • ê²½ë¡œ ì‚¬ìš©
                    console.warn('OSRM ê²½ë¡œ ì¡°íšŒ ì‹¤íŒ¨, ì¶”ì • ê²½ë¡œ ì‚¬ìš©');
                    await generateRouteWithEstimation(departure, arrival, mode, time, duration);
                }

            } catch (error) {
                console.error('OSRM API ì˜¤ë¥˜:', error);
                // API ì‹¤íŒ¨ ì‹œ ì¶”ì • ê²½ë¡œë¡œ ëŒ€ì²´
                console.log('ì¶”ì • ê²½ë¡œë¡œ ì „í™˜í•©ë‹ˆë‹¤.');
                await generateRouteWithEstimation(departure, arrival, mode, time, duration);
            }
        }

        // Nominatim APIë¡œ ì£¼ì†Œë¥¼ ì¢Œí‘œë¡œ ë³€í™˜
        async function geocodeAddress(address) {
            try {
                const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address + ', South Korea')}&limit=1`;

                const response = await fetch(url, {
                    headers: {
                        'User-Agent': 'TransitRouteVisualizer/1.0'
                    }
                });

                if (!response.ok) {
                    return null;
                }

                const data = await response.json();

                if (data && data.length > 0) {
                    return {
                        lat: parseFloat(data[0].lat),
                        lng: parseFloat(data[0].lon)
                    };
                }

                return null;
            } catch (error) {
                console.error('Geocoding ì˜¤ë¥˜:', error);
                return null;
            }
        }

        // OSRM ê²½ë¡œ ë°ì´í„° í‘œì‹œ
        function displayOSRMRoute(osrmData, startLoc, endLoc, departure, arrival, time, duration, distance, mode) {
            markersLayer.clearLayers();
            routeLayer.clearLayers();

            // ì‹œì‘/ì¢…ë£Œ ë§ˆì»¤
            addStartEndMarkers(startLoc, endLoc, departure, arrival, time, duration);

            const route = osrmData.routes[0];
            const totalDistance = (route.distance / 1000).toFixed(1); // km
            const totalDuration = Math.round(route.duration / 60); // ë¶„

            // OSRM ê²½ë¡œ ì¢Œí‘œë¥¼ Leaflet í˜•ì‹ìœ¼ë¡œ ë³€í™˜
            const coordinates = route.geometry.coordinates.map(coord => [coord[1], coord[0]]);

            // ê±°ë¦¬ì— ë”°ë¼ êµí†µìˆ˜ë‹¨ ë¶„ë¥˜
            let routes = createTransportSegments(coordinates, totalDistance, totalDuration, distance, mode);

            // ê²½ë¡œì„  ê·¸ë¦¬ê¸°
            routes.forEach((routeSegment, index) => {
                const color = getTransportColor(routeSegment.type);

                const routeLine = L.polyline(routeSegment.points, {
                    color: color,
                    weight: 4,
                    opacity: 0.7,
                    dashArray: routeSegment.type === 'walk' ? '10, 10' : null
                }).addTo(routeLayer);

                routeLine.bindPopup(`<b>${routeSegment.name}</b><br>${routeSegment.time}<br>${routeSegment.distance}`);

                // ì¤‘ê°„ ì§€ì  ë§ˆì»¤
                if (routeSegment.waypoint) {
                    L.marker([routeSegment.waypoint.lat, routeSegment.waypoint.lng], {
                        icon: L.divIcon({
                            html: `<div style="background: ${color}; color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 16px; border: 2px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.2);">${transportIcons[routeSegment.type]}</div>`,
                            className: '',
                            iconSize: [30, 30]
                        })
                    }).addTo(markersLayer).bindPopup(`<b>${routeSegment.name}</b><br>${routeSegment.time}`);
                }
            });

            // ì§€ë„ ë²”ìœ„ ì¡°ì •
            map.fitBounds(coordinates);

            // ê²½ë¡œ ì •ë³´ íŒ¨ë„ ì—…ë°ì´íŠ¸
            displayRouteInfo(routes, time);
        }

        // ì‹¤ì œ ê²½ë¡œë¥¼ êµí†µìˆ˜ë‹¨ë³„ë¡œ ë¶„í• 
        function createTransportSegments(coordinates, totalDistance, totalDuration, realDistance, mode) {
            let routes = [];
            const numPoints = coordinates.length;

            if (realDistance < 2) {
                // 2km ë¯¸ë§Œ - ë„ë³´ë§Œ
                routes.push({
                    type: 'walk',
                    name: 'ë„ë³´ ì´ë™',
                    time: totalDuration + 'ë¶„',
                    distance: totalDistance + 'km',
                    points: coordinates
                });
            } else if (realDistance < 10) {
                // 2-10km - ë²„ìŠ¤
                const midPoint = Math.floor(numPoints / 2);
                routes.push({
                    type: 'bus',
                    name: 'ì‹œë‚´ë²„ìŠ¤',
                    time: totalDuration + 'ë¶„',
                    distance: totalDistance + 'km',
                    waypoint: { lat: coordinates[midPoint][0], lng: coordinates[midPoint][1] },
                    points: coordinates
                });
            } else if (realDistance < 100) {
                // 10-100km - ë²„ìŠ¤ + ê¸°ì°¨ + ë„ë³´
                const segment1 = Math.floor(numPoints * 0.15);
                const segment2 = Math.floor(numPoints * 0.85);

                routes.push({
                    type: 'bus',
                    name: 'ì‹œë‚´ë²„ìŠ¤ í™˜ìŠ¹',
                    time: Math.round(totalDuration * 0.1) + 'ë¶„',
                    distance: (parseFloat(totalDistance) * 0.1).toFixed(1) + 'km',
                    waypoint: { lat: coordinates[segment1][0], lng: coordinates[segment1][1] },
                    points: coordinates.slice(0, segment1)
                });

                routes.push({
                    type: 'train',
                    name: realDistance > 50 ? 'KTX' : 'ì§€í•˜ì² /ê´‘ì—­ì „ì² ',
                    time: Math.round(totalDuration * 0.8) + 'ë¶„',
                    distance: (parseFloat(totalDistance) * 0.85).toFixed(1) + 'km',
                    waypoint: { lat: coordinates[Math.floor(numPoints/2)][0], lng: coordinates[Math.floor(numPoints/2)][1] },
                    points: coordinates.slice(segment1, segment2)
                });

                routes.push({
                    type: 'walk',
                    name: 'ë„ë³´ ì´ë™',
                    time: Math.round(totalDuration * 0.1) + 'ë¶„',
                    distance: (parseFloat(totalDistance) * 0.05).toFixed(1) + 'km',
                    points: coordinates.slice(segment2)
                });
            } else {
                // 100km ì´ìƒ - ì¥ê±°ë¦¬
                const segment1 = Math.floor(numPoints * 0.05);
                const segment2 = Math.floor(numPoints * 0.95);

                routes.push({
                    type: 'bus',
                    name: mode === 'plane' ? 'ê³µí•­ ì…”í‹€' : 'ì‹œë‚´ë²„ìŠ¤',
                    time: '20-25ë¶„',
                    distance: '10-15km',
                    waypoint: { lat: coordinates[segment1][0], lng: coordinates[segment1][1] },
                    points: coordinates.slice(0, segment1)
                });

                if (mode === 'plane' || realDistance > 300) {
                    routes.push({
                        type: 'plane',
                        name: 'êµ­ë‚´ì„  í•­ê³µí¸',
                        time: Math.round(60 + realDistance / 10) + 'ë¶„',
                        distance: realDistance.toFixed(0) + 'km',
                        waypoint: { lat: coordinates[Math.floor(numPoints/2)][0], lng: coordinates[Math.floor(numPoints/2)][1] },
                        points: coordinates.slice(segment1, segment2)
                    });
                } else {
                    routes.push({
                        type: 'train',
                        name: 'KTX/SRT',
                        time: Math.round(realDistance / 2.5) + 'ë¶„',
                        distance: realDistance.toFixed(0) + 'km',
                        waypoint: { lat: coordinates[Math.floor(numPoints/2)][0], lng: coordinates[Math.floor(numPoints/2)][1] },
                        points: coordinates.slice(segment1, segment2)
                    });
                }

                routes.push({
                    type: 'walk',
                    name: 'ë„ë³´ ì´ë™',
                    time: '10ë¶„',
                    distance: '0.8-1km',
                    points: coordinates.slice(segment2)
                });
            }

            return routes;
        }

        // API í‚¤ ì—†ì„ ë•Œ ê°œì„ ëœ ì¶”ì • ê²½ë¡œ ìƒì„±
        async function generateRouteWithEstimation(departure, arrival, mode, time, duration) {
            const startLoc = findLocation(departure);
            const endLoc = findLocation(arrival);

            // ì‹¤ì œ ê±°ë¦¬ ê³„ì‚°
            const actualDistance = calculateDistance(startLoc.lat, startLoc.lng, endLoc.lat, endLoc.lng);

            markersLayer.clearLayers();
            routeLayer.clearLayers();

            // ì‹œì‘/ì¢…ë£Œ ë§ˆì»¤
            addStartEndMarkers(startLoc, endLoc, departure, arrival, time, duration);

            // ê±°ë¦¬ì— ë”°ë¼ ì ì ˆí•œ ê²½ë¡œ ìƒì„±
            const routes = generateSmartRoute(startLoc, endLoc, actualDistance, mode);

            // ê²½ë¡œì„  ê·¸ë¦¬ê¸°
            let allPoints = [[startLoc.lat, startLoc.lng]];

            routes.forEach((route, index) => {
                const color = getTransportColor(route.type);

                if (route.waypoint) {
                    allPoints.push([route.waypoint.lat, route.waypoint.lng]);

                    // ì¤‘ê°„ ì§€ì  ë§ˆì»¤
                    L.marker([route.waypoint.lat, route.waypoint.lng], {
                        icon: L.divIcon({
                            html: `<div style="background: ${color}; color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 16px; border: 2px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.2);">${transportIcons[route.type]}</div>`,
                            className: '',
                            iconSize: [30, 30]
                        })
                    }).addTo(markersLayer).bindPopup(`<b>${route.name}</b><br>${route.time}`);
                }

                // ê²½ë¡œì„ 
                const routeLine = L.polyline(route.points, {
                    color: color,
                    weight: 4,
                    opacity: 0.7,
                    dashArray: route.type === 'walk' ? '10, 10' : null
                }).addTo(routeLayer);

                routeLine.bindPopup(`<b>${route.name}</b><br>${route.time}<br>${route.distance}`);
            });

            allPoints.push([endLoc.lat, endLoc.lng]);

            // ì§€ë„ ë²”ìœ„ ì¡°ì •
            map.fitBounds(allPoints);

            // ê²½ë¡œ ì •ë³´ íŒ¨ë„ ì—…ë°ì´íŠ¸
            displayRouteInfo(routes, time);
        }

        function addStartEndMarkers(startLoc, endLoc, departure, arrival, time, duration) {
            const startMarker = L.marker([startLoc.lat, startLoc.lng], {
                icon: L.divIcon({
                    html: '<div style="background: #10b981; color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 20px; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">ğŸ</div>',
                    className: '',
                    iconSize: [40, 40]
                })
            }).addTo(markersLayer);
            startMarker.bindPopup(`<b>ì¶œë°œ: ${departure}</b><br>${new Date(time).toLocaleString('ko-KR')}`);

            const endMarker = L.marker([endLoc.lat, endLoc.lng], {
                icon: L.divIcon({
                    html: '<div style="background: #ef4444; color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 20px; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">ğŸ¯</div>',
                    className: '',
                    iconSize: [40, 40]
                })
            }).addTo(markersLayer);
            endMarker.bindPopup(`<b>ë„ì°©: ${arrival}</b><br>ì˜ˆìƒ ${duration}ì¼ ì—¬í–‰`);
        }

        // ê±°ë¦¬ ê¸°ë°˜ ìŠ¤ë§ˆíŠ¸ ê²½ë¡œ ìƒì„±
        function generateSmartRoute(start, end, distance, mode) {
            let routes = [];

            if (distance < 2) {
                // 2km ë¯¸ë§Œ - ë„ë³´
                routes.push({
                    type: 'walk',
                    name: 'ë„ë³´ ì´ë™',
                    time: Math.round(distance * 15) + 'ë¶„',
                    distance: distance.toFixed(1) + 'km',
                    points: [[start.lat, start.lng], [end.lat, end.lng]]
                });
            } else if (distance < 10) {
                // 2-10km - ë²„ìŠ¤
                routes.push({
                    type: 'bus',
                    name: 'ì‹œë‚´ë²„ìŠ¤ ì´ë™',
                    time: Math.round(distance * 4) + 'ë¶„',
                    distance: distance.toFixed(1) + 'km',
                    waypoint: {
                        lat: start.lat + (end.lat - start.lat) * 0.5,
                        lng: start.lng + (end.lng - start.lng) * 0.5
                    },
                    points: [[start.lat, start.lng],
                             [start.lat + (end.lat - start.lat) * 0.5, start.lng + (end.lng - start.lng) * 0.5],
                             [end.lat, end.lng]]
                });
            } else if (distance < 100) {
                // 10-100km - ë²„ìŠ¤ + ê¸°ì°¨
                const busDistance = 3;
                const trainDistance = distance - busDistance - 1;

                routes.push({
                    type: 'bus',
                    name: 'ì‹œë‚´ë²„ìŠ¤ í™˜ìŠ¹',
                    time: Math.round(busDistance * 4) + 'ë¶„',
                    distance: busDistance.toFixed(1) + 'km',
                    waypoint: {
                        lat: start.lat + (end.lat - start.lat) * 0.1,
                        lng: start.lng + (end.lng - start.lng) * 0.1
                    },
                    points: [
                        [start.lat, start.lng],
                        [start.lat + (end.lat - start.lat) * 0.1, start.lng + (end.lng - start.lng) * 0.1]
                    ]
                });

                routes.push({
                    type: 'train',
                    name: distance > 50 ? 'KTX' : 'ì§€í•˜ì² /ê´‘ì—­ì „ì² ',
                    time: Math.round(trainDistance / (distance > 50 ? 2 : 0.5)) + 'ë¶„',
                    distance: trainDistance.toFixed(1) + 'km',
                    waypoint: {
                        lat: start.lat + (end.lat - start.lat) * 0.5,
                        lng: start.lng + (end.lng - start.lng) * 0.5
                    },
                    points: [
                        [start.lat + (end.lat - start.lat) * 0.1, start.lng + (end.lng - start.lng) * 0.1],
                        [start.lat + (end.lat - start.lat) * 0.5, start.lng + (end.lng - start.lng) * 0.5],
                        [end.lat - (end.lat - start.lat) * 0.05, end.lng - (end.lng - start.lng) * 0.05]
                    ]
                });

                routes.push({
                    type: 'walk',
                    name: 'ë„ë³´ ì´ë™',
                    time: '8-10ë¶„',
                    distance: '0.8km',
                    points: [
                        [end.lat - (end.lat - start.lat) * 0.05, end.lng - (end.lng - start.lng) * 0.05],
                        [end.lat, end.lng]
                    ]
                });
            } else {
                // 100km ì´ìƒ - ì¥ê±°ë¦¬ (ë¹„í–‰ê¸°/KTX)
                if (mode === 'plane' || distance > 300) {
                    routes.push({
                        type: 'bus',
                        name: 'ê³µí•­ ì…”í‹€',
                        time: '25ë¶„',
                        distance: '15km',
                        waypoint: {
                            lat: start.lat + (end.lat - start.lat) * 0.05,
                            lng: start.lng + (end.lng - start.lng) * 0.05
                        },
                        points: [
                            [start.lat, start.lng],
                            [start.lat + (end.lat - start.lat) * 0.05, start.lng + (end.lng - start.lng) * 0.05]
                        ]
                    });

                    routes.push({
                        type: 'plane',
                        name: 'êµ­ë‚´ì„  í•­ê³µí¸',
                        time: Math.round(60 + distance / 10) + 'ë¶„',
                        distance: distance.toFixed(0) + 'km',
                        waypoint: {
                            lat: start.lat + (end.lat - start.lat) * 0.5,
                            lng: start.lng + (end.lng - start.lng) * 0.5
                        },
                        points: [
                            [start.lat + (end.lat - start.lat) * 0.05, start.lng + (end.lng - start.lng) * 0.05],
                            [start.lat + (end.lat - start.lat) * 0.5, start.lng + (end.lng - start.lng) * 0.5],
                            [end.lat - (end.lat - start.lat) * 0.05, end.lng - (end.lng - start.lng) * 0.05]
                        ]
                    });
                } else {
                    routes.push({
                        type: 'bus',
                        name: 'ì‹œë‚´ë²„ìŠ¤',
                        time: '20ë¶„',
                        distance: '8km',
                        waypoint: {
                            lat: start.lat + (end.lat - start.lat) * 0.03,
                            lng: start.lng + (end.lng - start.lng) * 0.03
                        },
                        points: [
                            [start.lat, start.lng],
                            [start.lat + (end.lat - start.lat) * 0.03, start.lng + (end.lng - start.lng) * 0.03]
                        ]
                    });

                    routes.push({
                        type: 'train',
                        name: 'KTX/SRT',
                        time: Math.round(distance / 2.5) + 'ë¶„',
                        distance: distance.toFixed(0) + 'km',
                        waypoint: {
                            lat: start.lat + (end.lat - start.lat) * 0.5,
                            lng: start.lng + (end.lng - start.lng) * 0.5
                        },
                        points: [
                            [start.lat + (end.lat - start.lat) * 0.03, start.lng + (end.lng - start.lng) * 0.03],
                            [start.lat + (end.lat - start.lat) * 0.5, start.lng + (end.lng - start.lng) * 0.5],
                            [end.lat - (end.lat - start.lat) * 0.02, end.lng - (end.lng - start.lng) * 0.02]
                        ]
                    });
                }

                routes.push({
                    type: 'walk',
                    name: 'ë„ë³´ ì´ë™',
                    time: '10ë¶„',
                    distance: '0.9km',
                    points: [
                        [end.lat - (end.lat - start.lat) * 0.02, end.lng - (end.lng - start.lng) * 0.02],
                        [end.lat, end.lng]
                    ]
                });
            }

            return routes;
        }


        function getTransportColor(type) {
            const colors = {
                bus: '#10b981',
                train: '#3b82f6',
                plane: '#f59e0b',
                walk: '#6b7280'
            };
            return colors[type] || '#666';
        }

        function displayRouteInfo(routes, startTime) {
            const routeInfo = document.getElementById('routeInfo');
            const routeDetails = document.getElementById('routeDetails');

            let totalTime = 0;
            let html = '';
            let currentTime = new Date(startTime);

            routes.forEach((route, index) => {
                const timeInMinutes = parseInt(route.time);
                currentTime = new Date(currentTime.getTime() + timeInMinutes * 60000);

                html += `
                    <div class="route-segment">
                        <div class="route-icon">${transportIcons[route.type]}</div>
                        <div class="route-details">
                            <h4>
                                <span class="transport-${route.type}">${route.name}</span>
                            </h4>
                            <p>â±ï¸ ${route.time} | ğŸ“ ${route.distance}</p>
                            <p>ğŸ• ${currentTime.toLocaleTimeString('ko-KR', {hour: '2-digit', minute: '2-digit'})}</p>
                        </div>
                    </div>
                `;
            });

            routeDetails.innerHTML = html;
            routeInfo.style.display = 'block';
        }

        function showRecommendations(location, interests, foodPrefs) {
            const recPanel = document.getElementById('recommendations');
            const recList = document.getElementById('recommendationsList');

            // ìœ„ì¹˜ ê¸°ë°˜ ì¶”ì²œ ì°¾ê¸°
            let recs = [];
            for (const [loc, places] of Object.entries(recommendations)) {
                if (loc.includes(location) || location.includes(loc.replace('ì—­', ''))) {
                    recs = places;
                    break;
                }
            }

            // ê¸°ë³¸ ì¶”ì²œ (ìœ„ì¹˜ë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš°)
            if (recs.length === 0) {
                recs = recommendations['ì„œìš¸ì—­'];
            }

            // ì·¨í–¥ í•„í„°ë§
            const allPrefs = [...interests, ...foodPrefs];
            if (allPrefs.length > 0) {
                const filteredRecs = recs.filter(rec => allPrefs.includes(rec.type));
                if (filteredRecs.length > 0) {
                    recs = filteredRecs;
                }
            }

            // HTML ìƒì„±
            let html = '';
            recs.slice(0, 5).forEach(rec => {
                html += `
                    <div class="recommendation-item">
                        <h4>${rec.name}</h4>
                        <p>${rec.desc} â€¢ ${rec.category}</p>
                    </div>
                `;
            });

            recList.innerHTML = html || '<p>ì´ ì§€ì—­ì˜ ì¶”ì²œ ì¥ì†Œê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
            recPanel.style.display = 'block';
        }

        // í˜„ì¬ ì‹œê°„ìœ¼ë¡œ ê¸°ë³¸ê°’ ì„¤ì •
        window.addEventListener('DOMContentLoaded', function() {
            const now = new Date();
            now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
            document.getElementById('departureTime').value = now.toISOString().slice(0, 16);
        });
    </script>
</body>
</html>
